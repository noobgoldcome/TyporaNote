# 基础算法： 

## 第一章 : 基础算法(一)

### 快速排序 :

基础思想 : 分治

![image-20220804204423950](assets\image-20220804204423950.png)

![image-20220804204711794](assets\image-20220804204711794.png)

#### 模板:

```c++
void quick_sort(int q[ ], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```

#### 例题：

**快速排序**

> ![image-20230419151726467](assets\image-20230419151726467.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int n, q[N];

void quick_sort(int q[], int l, int r){
    if(l >= r) return;
    int mid = q[(l + r) / 2];
    int i = l - 1, j = r + 1;
    while(i < j){
        do i++; while(q[i] < mid);
        do j--; while(q[j] > mid);
        if(i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j+1, r);
    return;
}

int main(void){
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        scanf("%d", &q[i]);
    }
    quick_sort(q, 0, n-1);
    for(int i = 0; i < n; i++){
        printf("%d ", q[i]);
    }
    return 0;
}
```

### 归并排序 :

![image-20220804212657948](assets\image-20220804212657948.png)

![image-20220804213707426](assets\image-20220804213707426.png)

#### 模板：

```C++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

#### 例题：

**归并排序**

> ![image-20230419154758931](assets\image-20230419154758931.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int n;
int q[N], temp[N];

void merge_sort(int q[], int l, int r){
    if(l >= r) return;
    int mid = l + r >> 1;
    merge_sort(q, l, mid), merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while(i <= mid && j <= r){
        if(q[i] <= q[j]) temp[k++] = q[i++];
        else temp[k++] = q[j++];
    }
    while(i <= mid) temp[k++] = q[i++];
    while(j <= r) temp[k++] = q[j++];
    for(int i = l, j = 0; i <= r; i++, j++) q[i] = temp[j];
    return;
}

int main(void){
    scanf("%d", &n);
    for(int i = 0; i < n; i++)
        scanf("%d", &q[i]);
    merge_sort(q, 0, n-1);
    for(int i = 0; i < n; i++)
        printf("%d ", q[i]);
    return 0;
}
```

### 整数二分 :

![image-20220804220433923](assets\image-20220804220433923.png)

#### 模板：

```C++
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}
// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

实操的时候 

1. 先写一个mid
2. 然后写一个check函数 想一下区间该如何划分,考虑mid是否要加一

#### 例题：

**数的范围**

> ![image-20230419160325536](assets\image-20230419160325536.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int n, q;
int a[N];

int main(void){
    scanf("%d%d", &n, &q);
    for(int i = 0; i < n; i++)
        scanf("%d", &a[i]);
    while(q--){
        int k;
        scanf("%d", &k);
        int l = 0, r = n - 1;
        while(l < r){
            int mid = (l + r) / 2;
            if(a[mid] < k) l = mid + 1;
            else r = mid;
        }
        if(a[l] != k) cout << "-1 -1" << endl;
        else{
            cout << l << " ";
            int l = 0, r = n - 1;
            while(l < r){
                int mid = (l + r + 1) / 2;
                if(a[mid] <= k) l = mid;
                else r = mid - 1;
            }
            cout << l << endl;
        }
    }
    return 0;
}
```



### 浮点数二分 :

```C++
bool check(double x) {/* ... */} // 检查x是否满足某种性质

double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## 第一章 : 基础算法(二)

### 大整数加法 :

![image-20220830200124786](assets\image-20220830200124786.png)

#### 模板：

```C++
vector<int> add(vector<int> &A,vector<int> &B){
    vector<int>C;
    int t = 0;
    for(int i = 0 ;i<A.size()||i<B.size();i++){
        if(i<A.size()) t+=A[i];
        if(i<B.size()) t+=B[i];
        C.push_back(t%10);
        t/=10;
    }
    if(t) C.push_back(1);
    return C;
}
```

#### 例题：

**高精度加法**

> ![image-20230420212144846](assets\image-20230420212144846.png)

#### AC代码：

```C++
#include<iostream>
#include<vector>
const int N = 100010;
using namespace std;

vector<int> add(vector<int> &A, vector<int> &B){
    vector<int> C;
    int t = 0;
    for(int i = 0; i < A.size() || i < B.size(); i++){
        if(i < A.size()) t += A[i];
        if(i < B.size()) t += B[i];
        C.push_back(t % 10);
        t /= 10;
    }
    if(t) C.push_back(t);
    return C;
}

int main(void){
    vector<int> A, B;
    string a, b;
    cin >> a >> b;
    for(int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    auto C = add(A, B);
    for(int i = C.size() - 1; i >= 0; i--) cout << C[i];
}
```



### 大整数减法 :

![image-20220831112147786](assets\image-20220831112147786.png)

#### 模板：

```C++
#include<iostream>
#include<vector>
using namespace std;
bool cmp(vector<int> &A,vector<int> &B){
    if(A.size()!=B.size()) return A.size() > B.size();
    for(int i = A.size()-1; i >=0; i--){
        if(A[i]!=B[i]) return A[i]> B[i];
    }
    return true;
}
vector<int>sub(vector<int>&A,vector<int>&B){
    vector<int>C;
    int t = 0;
    for(int i = 0;i<A.size();i++){
        t = A[i] - t;
        if(i<B.size()) t-=B[i];
        C.push_back((t+10)%10);
        if(t<0) t = 1;
        else t = 0;
    }
    
    while(C.size()>1 &&C.back()== 0) C.pop_back();
    return C;
}
int main(){
    string a,b;
    vector<int>A, B;
    cin>>a>>b;
    for(int i = a.size()-1;i>=0;i--) A.push_back(a[i]-'0');
    for(int i = b.size()-1;i>=0;i--) B.push_back(b[i]-'0');
    if(cmp(A,B)){
        auto C = sub(A,B);
        for(int i = C.size()-1; i >= 0 ; i--) printf("%d",C[i]);
    }
    else{
        auto C = sub(B,A);
        printf("-");
        for(int i = C.size()-1; i >= 0 ; i--) printf("%d",C[i]);
    }
}
```

#### 例题：

**高精度减法**

> ![image-20230420214052500](assets\image-20230420214052500.png)

#### AC代码：

```C++
#include<iostream>
#include<vector>
using namespace std;

bool cmp(vector<int> &A, vector<int> &B){ //判断A是否大于等于B
    if(A.size() != B.size()) return A.size() > B.size();
    else{
        for(int i = A.size() - 1; i >= 0; i--){
            if(A[i] != B[i])
                return A[i] > B[i];
        }
    }
    return true;
}

vector<int> sub(vector<int> &A, vector<int> &B){ //高精度减法
    vector<int> C;
    for(int i = 0, t = 0; i < A.size(); i++){ //存的时候是倒着存的，操作的时候就正着操作
        t = A[i] - t; //总体思路就是A[i] - B[i] - t然后考虑要不要+10
        if(i < B.size()) t -= B[i];
        C.push_back((t + 10) % 10); //巧妙地处理+10问题
        if(t < 0) t = 1;//考虑借位问题
        else t = 0;
    }
    while(C.size() > 1 && C.back() == 0) //删除前导零
        C.pop_back();
    return C;
}

int main(void){
    string a, b;
    vector<int> A, B;
    cin >> a >> b;
    for(int i = a.size() - 1; i >= 0; i--) A.push_back(a[i] - '0');
    for(int i = b.size() - 1; i >= 0; i--) B.push_back(b[i] - '0');
    if(cmp(A, B)){ //记得分类讨论 调用不同的函数
        auto C = sub(A, B);
        for(int i = C.size() - 1; i >= 0; i--) cout << C[i];
    }else{
        auto C = sub(B, A);
        cout << "-";
        for(int i = C.size() - 1; i >= 0; i--) cout << C[i];
    }
    return 0;
}
```



### 高精度乘法：

![image-20220905090847617](assets\image-20220905090847617.png)

```C++
// C = A * b, A >= 0, b >= 0
vector<int> mul(vector<int> &A, int b)
{
    vector<int> C;

    int t = 0;
    for (int i = 0; i < A.size() || t; i ++ )
    {
        if (i < A.size()) t += A[i] * b;
        C.push_back(t % 10);
        t /= 10;
    }

    while (C.size() > 1 && C.back() == 0) C.pop_back();

    return C;
}
```

### 高精度除法

![image-20220905101758633](assets\image-20220905101758633.png)

```C++
// A / b = C ... r, A >= 0, b > 0
vector<int> div(vector<int> &A, int b, int &r)
{
    vector<int> C;
    r = 0;
    for (int i = A.size() - 1; i >= 0; i -- )
    {
        r = r * 10 + A[i];
        C.push_back(r / b);
        r %= b;
    }
    reverse(C.begin(), C.end());
    while (C.size() > 1 && C.back() == 0) C.pop_back();
    return C;
}
```

### 前缀和

![image-20220905165321142](assets\image-20220905165321142.png)

```C++
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

#### 例题：

**前缀和**

> ![image-20230505145627226](assets\image-20230505145627226.png)

#### AC代码：

```C++
#include<iostream>
using namespace std;
const int N = 100010;
int n, m;
int a[N], s[N];
int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        scanf("%d", &a[i]);
        s[i] = s[i-1] + a[i];
    }
    while(m--){
        int l, r;
        cin >> l >> r;
        cout << s[r] - s[l - 1] << endl;
    }
    return 0;
}
```



### 二维前缀和

![image-20220905173847157](assets\image-20220905173847157.png)

```C++
S[i, j] = 第i行j列格子左上部分所有元素的和
以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

#### 例题：

**子矩阵的和**

> ![image-20230505150758720](assets\image-20230505150758720.png)
>
> ![image-20230505150813909](assets\image-20230505150813909.png)

#### AC代码：

```C++
#include<iostream>
using namespace std;
const int N = 1010;
int n, m;
int a[N][N], s[N][N];
int q;
int main(void){
    cin >> n >> m >> q;
    for(int i = 1; i <= n; i ++){
        for(int j = 1; j <= m; j++){
            cin >> a[i][j];
            s[i][j] = s[i-1][j] + s[i][j-1] - s[i-1][j-1] + a[i][j];
        }
    }
    while(q --){
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        cout << s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1] << endl;
    }
    return 0;
}
```



### 一维差分

![image-20220906113145894](assets\image-20220906113145894.png)

```C++
给区间[l, r]中的每个数加上c：B[l] += c, B[r + 1] -= c
```

### 二维差分

```C++
给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

### 双指针算法

```C++
for (int i = 0, j = 0; i < n; i ++ )
{
    while (j < i && check(i, j)) j ++ ;

    // 具体问题的逻辑
}
常见问题分类：
    (1) 对于一个序列，用两个指针维护一段区间
    (2) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作
```

#### 例题：

**最长连续不重复子序列**

> ![image-20230519165803888](assets\image-20230519165803888.png)

#### AC代码

```C++
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 100010;
int n;
int a[N], s[N];

int main(void){
    cin >> n;
    for(int i = 0; i < n; i++){
        cin >> a[i];
    }
    int res = 0;
    int j = 0;
    for(int i = 0; i < n; i++){
        s[a[i]] ++;
        while(j <= i && s[a[i]] > 1){
            s[a[j]] --;
            j++;
        }
        res = max(res, i - j + 1);
    }
    cout << res;
    return 0;
}
```

### 位运算

![image-20220911092609411](assets\image-20220911092609411.png)

```C++
求n的第k位数字: n >> k & 1
返回n的最后一位1：lowbit(n) = n & -n
```

![image-20220911093536499](assets\image-20220911093536499.png)

#### 例题：

**二进制中1的个数**

> ![image-20230519170723805](assets\image-20230519170723805.png)

#### AC代码

```C++
#include <iostream>
using namespace std;
int lowbit(int x){
    return x & -x;
}
int main(void){
    int n;
    cin >> n;
    while(n --){
        int x;
        cin >> x;
        int res = 0;
        while(x){
            x -= lowbit(x);
            res++;
        }
        cout << res << " ";
    }
    return 0;
}
```

### 离散化

![image-20220911115234071](assets\image-20220911115234071.png)

```C++
vector<int> alls; // 存储所有待离散化的值
sort(alls.begin(), alls.end()); // 将所有值排序
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // 去掉重复元素

// 二分求出x对应的离散化的值
int find(int x) // 找到第一个大于等于x的位置
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // 映射到1, 2, ...n
}
```

#### 例题：

**区间和**

> ![image-20230522084727029](assets\image-20230522084727029.png)
>
> ![image-20230522084735846](assets\image-20230522084735846.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

const int N = 300010;

typedef pair<int, int> PII;

int n, m;
int a[N], s[N]; //存放离散后的下标以及前缀和

vector<int> alls;
vector<PII> add, query;

int find(int x){
    int l = 0, r = alls.size();
    while(l < r){
        int mid = l + r >> 1;
        if(alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return l + 1; //因为前缀和是从下标1开始处理
}

int main(void){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++){
        int x, c;
        scanf("%d%d", &x, &c);
        alls.push_back(x);
        add.push_back({x, c});
    }
    
    for(int i = 0; i < m; i++){
        int l, r;
        scanf("%d%d", &l, &r);
        query.push_back({l, r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    sort(alls.begin(), alls.end()); //排序
    alls.erase(unique(alls.begin(), alls.end()), alls.end());//去重
    
    for(auto item : add){
        int x = find(item.first);
        a[x] += item.second;
    }
    for(int i = 1; i <= alls.size(); i++) s[i] = s[i - 1] + a[i];//处理前缀和
    for(auto item : query){
        int l = find(item.first);
        int r = find(item.second);
        printf("%d\n", s[r] - s[l-1]);
    }
    return 0;
    
}
```



### 区间合并

#### 含义：

有若干段区间，将存在交集的多个区间合并成一个大区间

#### 步骤：

1. 按区间左端点排序
2. 扫描整个区间，扫描的过程中将可能有交集的区间合并

#### 例题：

**区间合并**

> ![image-20230522092012722](assets\image-20230522092012722.png)

#### AC代码

```C++
#include <vector>
#include <algorithm>
#include <iostream>

using namespace std;

const int N = 100010;

typedef pair<int, int> PII;

int n;

void merge(vector<PII> &seg){
    vector<PII> res;
    sort(seg.begin(), seg.end());
    int st = -2e9, ed = -2e9;
    for(auto item: seg){
        if(ed < item.first){
            if(st != -2e9) res.push_back({st, ed});
            st = item.first, ed = item.second;
        }
        else{
            ed = max(ed, item.second);
        }
    }   
    if(st != -2e9) res.push_back({st, ed});
    seg = res;
}

int main(void){
    scanf("%d", &n);
    vector<PII> seg;
    for(int i = 0; i < n; i++){
        int l, r;
        scanf("%d%d", &l, &r);
        seg.push_back({l, r});
    }
    merge(seg);
    cout << seg.size() << endl;
    return 0;
}
```

#### 模板：

```C++
// 将所有存在交集的区间合并
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
```

## 第二章：数据结构（一）

### 链表与邻接表

1. 单链表：邻接表（用于存储 **图** 和 **树**
2. 双链表：用来优化某些问题

#### 单链表模板：

```C++
// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点
int head, e[N], ne[N], idx;

// 初始化
void init()
{
    head = -1;
    idx = 0;
}

// 在链表头插入一个数a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}

// 将头结点删除，需要保证头结点存在
void remove()
{
    head = ne[head];
}
```

#### 单链表例题：

> ![image-20230522204438984](assets\image-20230522204438984.png)
>
> ![image-20230522204447107](assets\image-20230522204447107.png)

#### AC代码：

```C++
#include<iostream>
using namespace std;
const int N = 100010;
int e[N], ne[N], idx, head;
void init(){
    head = -1;
    idx = 0;
}

void add_to_head(int x){
    e[idx] = x;
    ne[idx] = head;
    head = idx++;
}

void add(int k, int x){
    e[idx] = x;
    ne[idx] = ne[k];
    ne[k] = idx++;
}

void del(int k){
    ne[k] = ne[ne[k]];
}

int main(void){
    int n;
    cin >> n;
    init();
    while(n --){
        char op;
        cin >> op;
        if(op == 'H'){
            int x;
            cin >> x;
            add_to_head(x);
        }else if(op == 'D'){
            int k;
            cin >> k;
            if(!k) head = ne[head];
            else del(k - 1);
        }else if(op == 'I'){
            int k, x;
            cin >> k >> x;
            add(k - 1, x);
        }
    }
    for(int i = head; i != -1; i = ne[i]){
        cout << e[i] << " ";
    }
    return 0;
}
```

#### 双链表模板：

```cpp
// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点
int e[N], l[N], r[N], idx;

// 初始化
void init()
{
    //0是左端点，1是右端点
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// 在节点a的右边插入一个数x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// 删除节点a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

### 栈和队列

#### 栈模板：

```cpp
// tt表示栈顶
int stk[N], tt = 0;

// 向栈顶插入一个数
stk[ ++ tt] = x;

// 从栈顶弹出一个数
tt -- ;

// 栈顶的值
stk[tt];

// 判断栈是否为空，如果 tt > 0，则表示不为空
if (tt > 0)
{

}
```

#### 队列模板：

```c++
//普通队列
// hh 表示队头，tt表示队尾
int q[N], hh = 0, tt = -1;

// 向队尾插入一个数
q[ ++ tt] = x;

// 从队头弹出一个数
hh ++ ;

// 队头的值
q[hh];

// 判断队列是否为空，如果 hh <= tt，则表示不为空
if (hh <= tt)
{

}
```

```c++
//循环队列
// hh 表示队头，tt表示队尾的后一个位置
int q[N], hh = 0, tt = 0;

// 向队尾插入一个数
q[tt ++ ] = x;
if (tt == N) tt = 0;

// 从队头弹出一个数
hh ++ ;
if (hh == N) hh = 0;

// 队头的值
q[hh];

// 判断队列是否为空，如果hh != tt，则表示不为空
if (hh != tt)
{

}
```

#### 单调栈模板：

```C++
常见模型：找出每个数左边离它最近的比它大/小的数
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

#### 单调栈例题：

> ![image-20230523145710080](assets\image-20230523145710080.png)

#### AC代码：

```C++
#include <iostream>
using namespace std;
const int N = 100010;
int stk[N], tt;
int main(void){
    int n;
    scanf("%d", &n);
    for(int i = 0; i < n; i++){
        int x;
        cin >> x;
        while(tt && stk[tt] >= x) tt--;
        if(tt) cout << stk[tt] << " ";
        else cout << -1 << " ";
        stk[++tt] = x;
    }
    return 0;
}
```

#### 单调队列模板：

```C++
常见模型：找出滑动窗口中的最大值/最小值
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

#### 单调队列例题：

**滑动窗口**

> ![image-20230523152827644](assets\image-20230523152827644.png)
>
> ![image-20230523152832824](assets\image-20230523152832824.png)

#### AC代码：

```C++
#include <iostream>
using namespace std;
const int N = 1000010;
int q[N], hh, tt = -1;
int a[N];
int n, k;
int main(void){
    scanf("%d%d", &n, &k);
    for(int i = 0; i < n; i++){
        int x;
        scanf("%d", &x);
        a[i] = x;
        if(hh <= tt && i - k + 1 > q[hh]) hh++;
        while(hh <= tt && x <= a[q[tt]]) tt--;
        q[++tt] = i;
        if(i >= k - 1) cout << a[q[hh]] << " ";
    }
    cout << endl;
    hh = 0;
    tt = -1;
    for(int i = 0; i < n; i++){
        if(hh <= tt && i - k + 1 > q[hh]) hh++;
        while(hh <= tt && a[i] >= a[q[tt]]) tt--;
        q[++tt] = i;
        if(i >= k - 1) cout << a[q[hh]] << " ";
    }
    cout << endl;
    return 0;
}
```

#### KMP模板

```C++
// s[]是长文本，p[]是模式串，n是s的长度，m是p的长度
求模式串的Next数组：
for (int i = 2, j = 0; i <= m; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}

// 匹配
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // 匹配成功后的逻辑
    }
}
```

## 第二章：数据结构（二）

### Trie树

#### 模板：

```C++
int son[N][26], cnt[N], idx;
// 0号点既是根节点，又是空节点
// son[][]存储树中每个节点的子节点
// cnt[]存储以每个节点结尾的单词数量

// 插入一个字符串
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}

// 查询字符串出现的次数
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

#### 用途：

高效存储和查找字符串集合的数据结构

#### 例题：

**Trie字符串统计**

> ![image-20230523184022544](assets\image-20230523184022544.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100010;
int son[N][26], cnt[N], idx;
int n;
void insert(char str[]){
    int p = 0;
    for(int i = 0; str[i]; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) son[p][u] = ++idx;
        p = son[p][u];
    }
    cnt[p] ++;
}

int query(char str[]){
    int p = 0;
    for(int i = 0; str[i]; i++){
        int u = str[i] - 'a';
        if(!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}

int main(void){
    cin >> n;
    char op[2];
    char str[N];
    while(n--){
        scanf("%s%s", op, str);
        if(op[0] == 'I') insert(str);
        else cout << query(str) << endl;;
    }
    return 0;
}
```

### 并查集

#### 模板：

```C++
(1)朴素并查集：

    int p[N]; //存储每个点的祖宗节点

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ ) p[i] = i;

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);


(2)维护size的并查集：

    int p[N], size[N];
    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        size[i] = 1;
    }

    // 合并a和b所在的两个集合：
    size[find(b)] += size[find(a)];
    p[find(a)] = find(b);


(3)维护到祖宗节点距离的并查集：

    int p[N], d[N];
    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离

    // 返回x的祖宗节点
    int find(int x)
    {
        if (p[x] != x)
        {
            int u = find(p[x]);
            d[x] += d[p[x]];
            p[x] = u;
        }
        return p[x];
    }

    // 初始化，假定节点编号是1~n
    for (int i = 1; i <= n; i ++ )
    {
        p[i] = i;
        d[i] = 0;
    }

    // 合并a和b所在的两个集合：
    p[find(a)] = find(b);
    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量
```

#### 含义：

1. 将两个集合合并
2. 询问两个元素是否在一个集合当中 **时间复杂度近乎O(1)**

基本原理：每个集合用一颗树来表示。树根的编号就是整个集合的编号。每个结点存储他的父节点，p[x]表示x的父节点

#### 例题：

**合并集合**

> ![image-20230523190209086](assets\image-20230523190209086.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100010;
int n, m;
int p[N];
int find(int x){
    if(p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(void){
    cin >> n >> m;
    for(int i = 0; i <= n; i++){
        p[i] = i;
    }
    while(m--){
        char op[2];
        int a, b;
        scanf("%s%d%d", op, &a, &b);
        if(op[0] == 'M') p[find(a)] = find(b);
        else{
            if(find(a) == find(b)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

### 堆：

#### 模板：

```C++
// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1
// ph[k]存储第k个插入的点在堆中的位置
// hp[k]存储堆中下标是k的点是第几个插入的
int h[N], ph[N], hp[N], size;

// 交换两个点，及其映射关系
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}

void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}

void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}

// O(n)建堆
for (int i = n / 2; i; i -- ) down(i);
```

#### 操作：

1. 插入一个数  heap[++size] = x; up(size)
2. 求集合当中的最小值 heap[1];
3. 删除最小值 heap[1] = heap[size]; size--; down(1)
4. 删除任意一个元素 heap[k] = heap[size]; size--; down(k); up(k);
5. 修改任意一个元素 heap[k] = x; down(k); up(k);

#### 例题：

> ![image-20230524151515679](assets\image-20230524151515679.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100010;
int n, m;
int h[N], s;

void down(int u){
    int t = u;
    if(2 * u <= s && h[2 * u] < h[t]) t = 2 * u;
    if(2 * u + 1 <= s && h[2 * u + 1] < h[t]) t = 2 * u + 1;
    if(t != u){
      swap(h[u], h[t]);
      down(t);
    } 
}

int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> h[i];
    }
    s = n;
    for(int i = n / 2; i; i--){ //O(n)建堆
        down(i);
    }
    while(m--){
        cout << h[1] << " ";
        h[1] = h[s];
        s --;
        down(1);
    }
    return 0;
}
```

### 哈希表：

#### 概述：

1. 存储结构
   - 开放寻址法
   - 拉链法
2. 字符串哈希方式

#### 模板：

```C++
(1) 拉链法
    int h[N], e[N], ne[N], idx;

    // 向哈希表中插入一个数
    void insert(int x)
    {
        int k = (x % N + N) % N;
        e[idx] = x;
        ne[idx] = h[k];
        h[k] = idx ++ ;
    }

    // 在哈希表中查询某个数是否存在
    bool find(int x)
    {
        int k = (x % N + N) % N;
        for (int i = h[k]; i != -1; i = ne[i])
            if (e[i] == x)
                return true;

        return false;
    }

(2) 开放寻址法
    int h[N];

    // 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置
    int find(int x)
    {
        int t = (x % N + N) % N;
        while (h[t] != null && h[t] != x)
        {
            t ++ ;
            if (t == N) t = 0;
        }
        return t;
    }
```

#### 例题：

**模拟散列表**

> ![image-20230524153758014](assets\image-20230524153758014.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100003;
int h[N], e[N], ne[N], idx;

void insert(int k){
    int x = (k % N + N) % N;
    e[idx] = k;
    ne[idx] = h[x];
    h[x] = idx++;
}

bool find(int k){
    int x = (k % N + N) % N;
    for(int i = h[x]; i != -1; i = ne[i]){
        if(e[i] == k) return true;
    }
    return false;
}

int main(void){
    int n;
    cin >> n;
    memset(h, -1, sizeof h);
    while(n--){
        char op[2];
        int k;
        cin >> op >> k;
        if(op[0] == 'I') insert(k);
        else{
            if(find(k)) puts("Yes");
            else puts("No");
        }
    }
    return 0;
}
```

#### 字符串哈希：

1. 将字符串看成p进制的数去转换成十进制的数   p取131 或者13331 Q取2^64
2. 对Q取模
3. 不能将字符映射成0
4. 人品足够好不存在冲突
5. 预处理前缀哈希值的好处是可以得到任一子串的哈希值 从L到R的哈希值为 h[R] - h[L-1] * p^ (R - L + 1)
6. 用unsigned long long来存储h 就不需要对Q取模了 因为溢出就是对2^64取模
7. 预处理： h[i] = h[i - 1] * p + str[i]

#### 模板：

```C++
核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低
小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果

typedef unsigned long long ULL;
ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64

// 初始化
p[0] = 1;
for (int i = 1; i <= n; i ++ )
{
    h[i] = h[i - 1] * P + str[i];
    p[i] = p[i - 1] * P;
}

// 计算子串 str[l ~ r] 的哈希值
ULL get(int l, int r)
{
    return h[r] - h[l - 1] * p[r - l + 1];
}
```

#### 例题：

> ![image-20230524161350813](assets\image-20230524161350813.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
const int N = 100010, P = 131;
typedef unsigned long long ULL;
int n, m;
ULL h[N], p[N];
char str[N];
ULL get(int l, int r){
    return h[r] - h[l - 1] * p[r - l + 1];
}

int main(void){
    cin >> n >> m >>str + 1;
    p[0] = 1;
    for(int i = 1; i <= n; i++){
        p[i] = p[i - 1] * P;
        h[i] = h[i - 1] * P + str[i];
    }
    while(m--){
        int l1, r1, l2, r2;
        cin >> l1 >> r1 >> l2 >> r2;
        if(get(l1, r1) == get(l2, r2)) puts("Yes");
        else puts("No");
    }
    return 0;
}
```

### STL

```C++
vector, 变长数组，倍增的思想
    size()  返回元素个数
    empty()  返回是否为空
    clear()  清空
    front()/back()
    push_back()/pop_back()
    begin()/end()
    []
    支持比较运算，按字典序

pair<int, int>
    first, 第一个元素
    second, 第二个元素
    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）

string，字符串
    size()/length()  返回字符串长度
    empty()
    clear()
    substr(起始下标，(子串长度))  返回子串
    c_str()  返回字符串所在字符数组的起始地址

queue, 队列
    size()
    empty()
    push()  向队尾插入一个元素
    front()  返回队头元素
    back()  返回队尾元素
    pop()  弹出队头元素

priority_queue, 优先队列，默认是大根堆
    size()
    empty()
    push()  插入一个元素
    top()  返回堆顶元素
    pop()  弹出堆顶元素
    定义成小根堆的方式：priority_queue<int, vector<int>, greater<int>> q;

stack, 栈
    size()
    empty()
    push()  向栈顶插入一个元素
    top()  返回栈顶元素
    pop()  弹出栈顶元素

deque, 双端队列
    size()
    empty()
    clear()
    front()/back()
    push_back()/pop_back()
    push_front()/pop_front()
    begin()/end()
    []

set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列
    size()
    empty()
    clear()
    begin()/end()
    ++, -- 返回前驱和后继，时间复杂度 O(logn)

    set/multiset
        insert()  插入一个数
        find()  查找一个数
        count()  返回某一个数的个数
        erase()
            (1) 输入是一个数x，删除所有x   O(k + logn)
            (2) 输入一个迭代器，删除这个迭代器
        lower_bound()/upper_bound()
            lower_bound(x)  返回大于等于x的最小的数的迭代器
            upper_bound(x)  返回大于x的最小的数的迭代器
    map/multimap
        insert()  插入的数是一个pair
        erase()  输入的参数是pair或者迭代器
        find()
        []  注意multimap不支持此操作。 时间复杂度是 O(logn)
        lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表
    和上面类似，增删改查的时间复杂度是 O(1)
    不支持 lower_bound()/upper_bound()， 迭代器的++，--

bitset, 圧位
    bitset<10000> s;
    ~, &, |, ^
    >>, <<
    ==, !=
    []

    count()  返回有多少个1

    any()  判断是否至少有一个1
    none()  判断是否全为0

    set()  把所有位置成1
    set(k, v)  将第k位变成v
    reset()  把所有位变成0
    flip()  等价于~
    flip(k) 把第k位取反
```



## 第三章：搜索与图论（一）

### 大纲:

- 深度优先搜索 DFS
- 宽度优先搜索 BFS
- 树与图的存储
- 树与图的深度优先遍历
- 树与图的宽度优先遍历
- 拓扑排序

### 深度优先搜索 DFS

#### 算法分析：

DFS：使用stack来存储，空间复杂度为O（h）DFS搜到的点不具有最短性

#### 例题：

全排列问题：

> ![image-20230319150247054](assets\image-20230319150247054.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 10;
int n;
int path[N];
bool st[N];
//这个dfs算法传入的参数是当前考虑的位数，如果考虑到最后一位了直接输出，否则遍历是否可以使用此点。
void dfs(int u){
    if(u == n){
        for(int i = 0; i < n; i++){
            printf("%d ", path[i]);
        }
        cout << endl;
        return;
    }
    for(int i = 1; i <= n; i++){
        if(!st[i]){
            path[u] = i;
            st[i] = true;
            dfs(u + 1);
            st[i] = false;//恢复现场，这点很重要！
        }
    }
    return;
}

int main(void){
    scanf("%d", &n);
    dfs(0);
    return 0;
}
```

#### 例题：

八皇后问题：

> ![image-20230319152908341](assets\image-20230319152908341.png)
> ![image-20230319152932572](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230319152932572.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 10;
char g[N][N];
bool col[N], dg[2 * N], udg[2 * N];
int n;

void dfs(int u){
    if(u == n){
        for(int i = 0; i < n; i++) puts(g[i]);
        puts("");
        return;
    }
    for(int i = 0; i < n; i++){
        if(!col[i] && !dg[u + i ] && !udg[n - u + i]){
            g[u][i] = 'Q';
            col[i] = dg[u + i ] = udg[n - u + i] = true;
            dfs(u+1);
            col[i] = dg[u + i ] = udg[n - u + i] = false;
            g[u][i] = '.';
        }
    }
    return;
}

int main(void){
    scanf("%d", &n);
    for(int i = 0; i < n; i ++){
        for(int j = 0; j < n; j++){
            g[i][j] = '.';
        }
    }
    dfs(0);
    return 0;
}
```



### 宽度优先搜索 BFS

#### 算法分析：

BFS：使用queue来存储，空间复杂度为O（2^n） BFS第一次扩展到的点一定是最短路的点
当边权为1时， 最短路可以用BFS来搜索

#### 算法思路：

初始化队列 queue

while queue不空

{

​	令队头 → t；

​	扩展 t；

}

#### 例题：

走迷宫

> ![image-20230319155824709](assets\image-20230319155824709.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 110;
typedef pair<int, int> PII;
int g[N][N];
int d[N][N];
int n, m;
PII q[N * N];
int bfs(){
    int hh = 0, tt = -1;
    q[++tt] = {0, 0};
    memset(d, -1, sizeof d);
    d[0][0] = 0;
    int dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};
    while(hh <= tt){
        auto t = q[hh++];
        for(int i = 0; i < 4; i++){
            int x = t.first + dx[i], y = t.second + dy[i];
            if(x >= 0 && x < n && y >= 0 && y < m && g[x][y] == 0 && d[x][y] == -1){
                d[x][y] = d[t.first][t.second] + 1;
                q[++tt] = {x, y};
            }
        }
    }
    return d[n-1][m-1];
}

int main(void){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < n; i++){
        for(int j = 0; j < m; j++){
            scanf("%d", &g[i][j]);
        }
    }
    cout << bfs() << endl;
    return 0;
}
```

### 树与图的存储

树是一种特殊的图，与图的存储方式相同。
对于无向图中的边ab，存储两条有向边a->b, b->a。
因此我们可以只考虑有向图的存储。

(1) 邻接矩阵：g[a] [b] 存储边a->b

(2) 邻接表：

```C++
// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点
int h[N], e[N], ne[N], idx;

// 添加一条边a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

// 初始化
idx = 0;
memset(h, -1, sizeof h);
```



### 树与图的深度优先遍历

#### 代码模板：

```C++
int dfs(int u)
{
    st[u] = true; // st[u] 表示点u已经被遍历过

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j]) dfs(j);
    }
}
```

#### 例题：

树的重心

> ![image-20230319163656761](assets\image-20230319163656761.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 100010, M = N * 2;
int h[N], e[M], ne[M], idx;
bool st[N];
int ans = N;
int n;

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int dfs(int u){
    st[u] = true;
    int sum = 1, res = 0;
    for(int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if(!st[j]){
            int s = dfs(j);
            res = max(res, s);
            sum += s;
        }
    }
    res = max(res, n - sum);
    ans = min(ans, res);
    return sum;
}

int main(void){
    cin >> n;
    memset(h, -1, sizeof h);
    for(int i = 0; i < n - 1; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        add(b, a);
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```

### 树与图的宽度优先遍历

#### 代码模板：

```C++
queue<int> q;
st[1] = true; // 表示1号点已经被遍历过
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

    for (int i = h[t]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true; // 表示点j已经被遍历过
            q.push(j);
        }
    }
}
```

#### 例题：

图中点的层次

> ![image-20230319164435759](assets\image-20230319164435759.png)

#### AC代码：

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 100010;
int n, m;
int e[N], ne[N], h[N], idx;
int q[N], d[N];

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

int bfs(int u){
    q[0] = 1;
    memset(d, -1, sizeof d);
    d[1] = 0;
    int hh = 0, tt = 0;
    while(hh <= tt){
        int t = q[hh++];
        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(d[j] == -1){
                d[j] = d[t] + 1;
                q[++tt] = j;
            }
        }
    }
    return d[n];
}

int main(void){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
    }
    cout << bfs(1) <<endl;
    return 0;
}
```

### 拓扑排序

> 有向无环图一定存在拓扑序列

#### 算法思路：

queue←所有入度为0的点

while queue不空

{

​		t ← 队头；

​		枚举t的所有出边 t → j；

​		删除t → j；//让j的入度--；

​		if( d[j] == 0 )

​			queue ← j； 

}

#### 代码模板：

```C++
bool topsort()
{
    int hh = 0, tt = -1;

    // d[i] 存储点i的入度
    for (int i = 1; i <= n; i ++ )
        if (!d[i])
            q[ ++ tt] = i;

    while (hh <= tt)
    {
        int t = q[hh ++ ];

        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (-- d[j] == 0)
                q[ ++ tt] = j;
        }
    }

    // 如果所有点都入队了，说明存在拓扑序列；否则不存在拓扑序列。
    return tt == n - 1;
}
```

#### 例题：

> ![image-20230319165711996](assets\image-20230319165711996.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 100010;
int n, m;
int e[N], h[N], ne[N], idx;
int q[N], d[N];
void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool topsort(void){
    int hh = 0, tt = -1;
    for(int i = 1; i <= n; i++){
        if(!d[i]) q[++tt] = i;
    }
    while(hh <= tt){
        int t = q[hh++];
        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            d[j] --;
            if(d[j] == 0) q[++tt] = j;
        }
    }
    return tt == n - 1;
}

int main(void){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++){
        int a, b;
        cin >> a >> b;
        add(a, b);
        d[b] ++;
    }
    if(topsort()){
        for(int i = 0; i < n; i++) printf("%d ", q[i]);
    }else{
        cout << "-1" << endl;
    }
}
```



## 第三章：搜索与图论（二）

> 最短路问题难点在于 如何从题目背景中抽象出图，而不是证明为何是正确的！经验最重要！！

### 大纲：

#### 一：单源最短路

##### 1. 所有边权都是正数

- 朴素Dijkstra算法 O(n^2)
- 堆优化版Dijkstra算法 O(mlogn) m为边数，n为点数

##### 2.存在负权边

- Bellman-Ford O(nm)
- SPFA 一般O(m), 最差O(mn) 只要图中无负环，就可用SPFA

#### 二：多源汇最短路

##### Floyd算法 O(n^3)

### 朴素Dijkstra算法

`时间复杂度：O(n^2)`  `用邻接矩阵存储， 适合稀疏图`

#### 算法思路：

1. 初始化 dist[1] = 0, dist[i] = 0x3f3f3f3f

2. for(int i = 1; i <= n; i++){  //S：目前已经确定最短距离的点的集合

   ​	t 赋值为不在S中距离最近的点

   ​	S ← t (标记t进入S集合)

   ​	用 t 更新其他点的距离
   }

#### 例题：

> ![image-20230320194758024](assets\image-20230320194758024.png)
> ![image-20230320194805189](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230320194805189.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 510;
int n, m;
int g[N][N];
int dist[N]; //距离数组
bool st[N]; //用来判断是否在S数组内

int dijkstra(void){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;//初始化距离点集， 第一个点到第一个点的距离为0；
    for(int i = 1; i <= n; i++ ){
        int t = -1;
        for(int j = 1; j <= n; j++){ //寻找t
            if(!st[j] && (t == -1 || dist[t] > dist[j])){
                t = j;
            }
        }
        st[t] = true; //将t放入集合；
        for(int j = 1; j <= n; j++){
            dist[j] = min(dist[j], dist[t] + g[t][j]); //三角形更新其他所有点的距离
        }
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    return dist[n];
}

int main(void){
    scanf("%d%d", &n, &m);
    memset(g, 0x3f, sizeof g); // 初始化邻接矩阵
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = min(g[a][b], c); //防止重边，取最小边即可；
    }
    int t = dijkstra();
    printf("%d\n", t);
    return 0;
}
```

### 堆优化版Dijkstra算法 O(mlogn)

`时间复杂度O(mlogn)，适合稠密图 `

#### 例题：

> ![image-20230320200100418](assets\image-20230320200100418.png)
>
> <img src="assets\image-20230320200106818.png" alt="image-20230320200106818"  />

#### AC代码：

```C++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;
const int N = 1000010;
typedef pair<int, int> PII;
priority_queue<PII, vector<PII>, greater<PII>> heap;//小根堆，第一个元素代表距离，是排序的第一优先级，第二个元素代表当前点的编号
int h[N], w[N], e[N], ne[N], idx;
int n, m;
int dist[N];
bool st[N];
void add(int a, int b, int c){
    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;
}

int djistra(){
    heap.push({0, 1});
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    while(heap.size()){ //从集合中找出距离最小的元素
        auto t = heap.top();
        heap.pop();
        int ver = t.second, distance = t.first;
        if(st[ver]) continue; //如果是冗余备份就继续
        for(int i = h[ver]; i != -1; i = ne[i]){//对当前堆顶元素ver能扩展到的点进行松弛
            int j = e[i];
            if(dist[j] > distance + w[i]){
                dist[j] = distance + w[i];
                heap.push({dist[j], j});
            }
        }
        st[ver] = true;//处理完这个点应该放入s集合
    }
    if(dist[n] == 0x3f3f3f3f) return -1;
    else return dist[n];
}

int main(void){
    cin >> n >> m;
    memset(h, -1, sizeof h);
    while(m--){
        int a, b, c;
        cin >> a >> b >> c;
        add(a, b, c);
    }
    int t = djistra();
    cout << t << endl;
    return 0;
}
```

### Bellman-Ford

`时间复杂度O(nm)`  `若有负权回路则不一定存在最短路`

#### 算法思路：

for n 次

​	for 所有边 a, b, w

​		dist[b] = min(dist[b], dist[a] + w);

当最外层迭代k次时，意味着最多不超过k条边所能到达的最短距离

对所有的边满足三角不等式：dist[b] ≤ dist[a] + w;

#### 例题：

> ![image-20230320202323274](assets\image-20230320202323274.png)
>
> ![image-20230320202329308](assets\image-20230320202329308.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 510, M = 10010;
int n, m, k;
struct{
    int a, b, w;
}edge[M];//用一个结构体来表示边集， 因为这个算法不需要遍历点
int dist[N], backup[N]; // backup[N] 用来备份dist[N], 防止一条边的连锁反应

int bellman_ford(void){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    for(int i = 0; i < k; i++){
        memcpy(backup, dist, sizeof dist);
        for(int j = 0; j < m; j++){
            int a = edge[j].a;
            int b = edge[j].b;
            int w = edge[j].w;
            dist[b] = min(dist[b], backup[a] + w);
        }
    }
    return dist[n];
}

int main(void){
    scanf("%d%d%d", &n, &m, &k);
    for(int i = 0; i < m; i++){
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edge[i] = {a, b, w};
    }
    int t = bellman_ford();
    if(t > 0x3f3f3f3f/2) printf("impossible");//防止卡负权边
    else printf("%d", t);
}

```

### SPFA

#### 算法思路：

是优化版的Bellman-Ford算法

queue ← 起点

while(队列不空){

 	1. t ← q.front();
 	 q.pop();
 	2. 更新t的所有出边 t → b 权值为w
 	 queue ← b;

}

#### 例题：

> ![image-20230321183111663](assets\image-20230321183111663.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N = 100010;
int h[N],e[N],ne[N],w[N],idx; //用邻接表存储
int n, m;
int dist[N];
bool st[N];
void add(int a, int b, int val){
    e[idx] = b, w[idx] = val, ne[idx] = h[a], h[a] = idx++;
}

int spfa(){
    memset(dist, 0x3f, sizeof dist); //初始化距离数组
    dist[1] = 0;
    queue<int> q;
    q.push(1);
    st[1] = true;
    while(q.size()){
        int  t = q.front();
        q.pop();
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                if(!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dist[n];
    
}

int main(void){
    scanf("%d%d",&n, &m);
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++){
        int a,  b,  val;
        scanf("%d%d%d",&a, &b, &val);
        add(a, b, val);
    }
    int t = spfa();
    if(t == 0x3f3f3f3f) printf("impossible");
    else printf("%d\n",t);
    return 0;
}

```

### 用SPFA判断是否存在负环

#### 算法思路：

1. 添加cnt[N]数组来记录边数
2. 更新
   - dist[x] = dist[t] + w[i];
   - cnt[x] = cnt[t] + 1;

3. 判断 if(cnt[x] >= n) return true;

#### 例题：

> ![image-20230321183530125](assets\image-20230321183530125.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N = 100010;
int h[N],e[N],ne[N],w[N],idx;
int n, m;
int dist[N],cnt[N];
bool st[N];
void add(int a, int b, int val){
    e[idx] = b, w[idx] = val, ne[idx] = h[a], h[a] = idx++;
}

bool spfa(){
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    queue<int> q;
    for(int i = 1; i <= n; i++){ //把所有点集都加入到队列中， 以防联通性
        st[i] = true;
        q.push(i);
    } 
    while(q.size()){
        int  t = q.front();
        q.pop();
        st[t] = false;
        for(int i = h[t]; i != -1; i = ne[i]){
            int j = e[i];
            if(dist[j] > dist[t] + w[i]){
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if(cnt[j] >= n) return true; //随时判断是否产生负环
                if(!st[j]){
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
    
}

int main(void){
    scanf("%d%d",&n, &m);
    memset(h, -1, sizeof h);
    for(int i = 0; i < m; i++){
        int a,  b,  val;
        scanf("%d%d%d",&a, &b, &val);
        add(a, b, val);
    }
    if(spfa()) printf("Yes");
    else printf("No");
    return 0;
}

```

### Floyd算法：

#### 算法思路：

邻接矩阵存储，三重循环，从外到内依次为k, i, j

维护矩阵：d[i, j] = min(d[i,j], d[i,k] + d[k, j]);

#### 例题：

> ![image-20230321184025347](assets\image-20230321184025347.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 210, INF = 1e9;
int n, m, Q;
int d[N][N];
void floyd(){
    for(int k = 1; k <= n; k++){
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= n; j++){
                d[i][j] = min(d[i][j], d[i][k]+d[k][j]);
            }
        }
    }
}

int main(void){
    scanf("%d%d%d", &n, &m, &Q);
    for(int i = 1; i <= n; i++){
        for(int j = 1; j <= n; j++){
            if(i == j) d[i][j] = 0;
            else d[i][j] = INF;
        }
    }
    while(m--){
        int a, b, c;
        scanf("%d%d%d",&a, &b, &c);
        d[a][b] = min(d[a][b],c);
    }
    floyd();
    while(Q--){
        int a,  b;
        scanf("%d%d", &a, &b);
        int t = d[a][b];
        if(t >= INF/2) printf("impossible\n");
        else printf("%d\n",t);
    }
    return 0;
}
```



## 第三章：搜索与图论（三）

### 大纲：

#### 一：最小生成树

- 普利姆算法（Prim）
  1. 朴素版Prim `O(n^2)`
  2. 堆优化Prim`O(mlogn)`  （很少用到）
- 克鲁斯卡尔算法（Kruskal） `O(mlogm)`

#### 二：二分图

- 染色法 `O(n+m)`
- 匈牙利算法 `O(mn)`  `实际运行时间远小于O(mn)`

### 朴素版Prim算法

#### 算法思路：

1. 首先初始化每个点到`集合`的距离为正无穷

 2. for(int i = 0; i < n; i++) //进行 n 次循环

    {

    ​		找到集合外距离最近的点赋值给点t

    ​		用 t 来更新其他点到`集合`的距离

    ​		st[t] = true; //把点t加入`集合`

    }

#### 例题：

> ![image-20230315195125670](assets\image-20230315195125670.png)
> ![image-20230315195147207](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230315195147207.png)

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 510 ,INF = 0x3f3f3f3f;
int n, m;
int g[N][N];
int dist[N];
bool st[N];

int prim(){
    memset(dist,0x3f, sizeof dist);
    int res = 0;
    for(int i = 0; i < n; i++){
        int t = -1;
        for(int j = 1; j <= n; j++){
            if(!st[j] && (t == -1 || dist[t] > dist[j])){
                t = j;
            }
        }
        if(i && dist[t] == INF) return INF;
        if(i) res += dist[t];
        st[t] = true;
        for(int j = 1; j <= n; j++){
            dist[j] = min(dist[j], g[t][j]);
        }
    }
    return res;
}

int main(void){
    scanf("%d%d", &n, &m);
    memset(g,0x3f, sizeof g);
    while(m--){
        int a, b, c;
        scanf("%d%d%d", &a, &b, &c);
        g[a][b] = g[b][a] = min(g[a][b],c);
    }
    int t = prim();
    if(t == INF) printf("impossible\n");
    else printf("%d\n",t);
    return 0;
}

```

### 克鲁斯卡尔算法（Kruskal）

#### 算法思路：

1. 将所有边按权重从大到小排序 `O(mlogm)`
2. 枚举每条边a b，权重c
   if（a，b不连通）
       将这条边加入到集合中

#### 例题：

> ![image-20230315203748599](assets\image-20230315203748599.png)
> ![image-20230315203759565](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230315203759565.png)

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 200010, INF = 0x3f3f3f3f;
int p[N];
int n, m;
struct Edge{
    int a, b, w;
    bool operator < (const Edge& W) const{
        return w < W.w;
    }
}edges[N];

int find(int x){
    if(p[x]!=x) p[x] = find(p[x]);
    return p[x];
}

int kruskal(){
    for(int i = 1; i <= n; i++){
        p[i] = i;
    }
    int res = 0, cnt = 0;
    sort(edges, edges + m);
    for(int i = 0; i < m; i++){
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if(a != b){
            p[a] = b;
            res += w;
            cnt++;
        }
    }
    if(cnt < n - 1) return INF;
    return res;
}

int main(){
    scanf("%d%d", &n, &m);
    for(int i = 0; i < m; i++){
        int a, b, w;
        scanf("%d%d%d", &a, &b, &w);
        edges[i] = {a, b, w};
    }
    
    int t = kruskal();
    if(t == INF) printf("impossible\n");
    else printf("%d\n",t);
    return 0;
}

```

> 💘fine

### 染色法

#### 算法思路：

什么是二分图：吧一个无向图的点分为两个集合，若每个集合中没有边连接，仅有集合之间的点进行连接，那么这个图叫二分图。

二分图当且仅当图中不含有奇数环

for (int i = 1; i <= n; i++){

​	if(i未染色){

​		dfs(i, color);	

​     }

}

#### 例题

> <img src="assets\image-20230317152354720.png" alt="image-20230317152354720" style="zoom:50%;" />

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 100010, M = 200010;
int h[N], e[M], ne[M], color[N], idx;
int n, m;

int add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool dfs(int u, int c){
    color[u] = c;
    for(int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        if(!color[j]){
            if(!dfs(j, 3 - c)){
                return false;
            }
        }
        else if(color[j] == c){
            return false;
        }
    }
    return true;
}

int main(void){
    scanf("%d%d", &n, &m);
    memset(h, -1, sizeof h);
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    
    bool flag = true;
    for(int i = 1; i <= n; i++){
        if(!color[i]){
            if(!dfs(i, 1)){
                flag = false;
                break;
            }
        }
    }
    if(flag) printf("Yes");
    else printf("No");
    return 0;
}

```

### 匈牙利算法

#### 算法思路：

什么是二分图的最大匹配：给定一个二分图G，在G的一个子图M中， M的边集{E}中的**任意两条边都不交汇于同一个结点**，则称M是一个匹配。

给定一个二分图，求二分图的最大匹配

匈牙利算法准则：待字闺中，据为己有；名花有主，求他放手。

#### 例题：

> ![image-20230317161006400](assets\image-20230317161006400.png)
> ![image-20230317161015735](C:\Users\86188\AppData\Roaming\Typora\typora-user-images\image-20230317161015735.png)

#### AC代码

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 510, M = 100010;
int n1, n2, m;
int h[N], e[M], ne[M], idx;//邻接表的存储结构
int match[N];//记录右边的点集跟左边那个点相匹配
bool st[N];//判断这个点有没有被遍历过

void add(int a, int b){
    e[idx] = b, ne[idx] = h[a], h[a] = idx++;
}

bool find(int x){ //寻找匹配函数
    for(int i = h[x]; i != -1; i = ne[i]){ //遍历从x点向右边点集的边
        int j = e[i];//用j来记录当前遍历到的右边的点
        if(!st[j]){ //如果当前右边的点没有被遍历过， 这里是为了再次调用find函数时，可以跳过当前这个点，否则会死循环
            st[j] = true;//先标记当前点
            if(match[j] == 0 || find(match[j])){  //如果这个点没有与左边点匹配，或者  左边的那个点可以再找一个别的点
                match[j] = x; //就把j 跟 x 连接
                return true;
            }
        }
    }
    return false;
}

int main(void){
    scanf("%d%d%d", &n1, &n2, &m);
    memset(h, -1, sizeof h);//初始化
    while(m--){
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b);
    }
    
    int res = 0;
    for(int i = 1; i <= n1; i++){
        memset(st, false, sizeof st);//每次遍历，都初始化st数组，当没有找过来算
        if(find(i)) res++;
    }
    printf("%d\n", res);
    return 0;
}
```

## 第四章：数学知识（一）

### 大纲：

#### 一：质数

#### 二：约数

### 质数

#### 定义：

在大于1的整数中，如果只包含1和本身这两个约束，就被称为质数，或者素数。

#### 试除法判定质数

时间复杂度 O(sqrt(n)) 一定是sqrt(n)

##### 模板：

```C++
bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ ) // 不推荐写sqrt（n） 因为每次循环都要执行sqrt 很慢
        if (x % i == 0)						//也不推荐写i*i<=n 因为存在溢出风险
            return false;
    return true;
}
```

##### 例题：

> ![image-20230321174754146](assets\image-20230321174754146.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
typedef long long LL;
int n;

bool fun(LL x)
{
    if(x < 2) return false;
    for(int i = 2; i <= x/i; i++){
        if(x % i == 0){
            return false;
        }
    }
    return true;
}

int main(void){
    scanf("%d", &n);
    while(n--){
        LL x;
        cin >> x;
        if(fun(x)) printf("Yes\n");
        else printf("No\n");
    }
    return 0;
}
```



#### 试除法分解质因数

性质：一个数最多只有一个大于sqrt（n）的质因子

时间复杂度 O(sqrt(n)) 最好是log(n) 最次是sqrt(n)

##### 模板：

```C++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

##### 例题：

> ![image-20230321175958048](assets\image-20230321175958048.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
int main(void){
    scanf("%d", &n);
    while(n--){
        int x;
        scanf("%d", &x);
        for(int i = 2; i <= x/i; i++){
            if(x % i == 0){
                int t = 0;
                while(x % i == 0){
                    x /= i;
                    t++;
                }
                printf("%d %d\n", i, t);
            }
        }
        if(x > 1) printf("%d %d\n", x , 1); //记得要处理特殊情况！！
        puts("");
    }
    return 0;
}
```



#### 朴素筛法求素数

##### 算法思路：

从2到n以此遍历 ， 在2 ~ n中依次删除i的倍数

时间复杂度 O(nlogn)

##### 模板：

```C++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

##### 例题：

> ![image-20230321180721096](assets\image-20230321180721096.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 1000010;
bool st[N];
int primes[N], cnt;
int n;
int main(void){
    scanf("%d", &n);
    for(int i = 2; i <= n; i++){
        if(st[i]) continue;
        primes[cnt++] = i;
        for(int j = i + i; j <= n; j += i){
            st[j] = true; //注意下标错误！
        }
    }
    printf("%d", cnt);
    return 0;
}
```



#### 线性筛法求素数

##### 算法思路：

n之会被最小质因子筛掉 

两种情况（从小到大枚举pj）：

1. i % pj == 0
   pj一定是i的最小质因子，pj也一定是pj * i 的最小质因子
2. i % pj ！= 0
   pj一定小于i的所有质因子，pj也一定是pj * i的最小质因子

所有和数都会被筛选掉，并且只会被筛选一次，所以是线性筛法。

##### 模板：

```C++
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

### 约数：

#### 试除法求所有约数

##### 模板：

```C++
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}
```

##### 例题：

> ![image-20230321181817020](assets\image-20230321181817020.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<vector>
using namespace std;
int n;

void fun(int x){
    vector<int> res;
    for(int i = 1; i <= x / i; i++){
        if(x % i == 0){
            if(i == x / i) res.push_back(i); //以及vector 如何添加元素。
            else{
                res.push_back(i);
                res.push_back(x / i);
            }
        }
    }
    sort(res.begin(), res.end()); //注意sort的写法；
    for(auto i : res){ 
        printf("%d ", i);
    }
    puts("");
}

int main(void){
    scanf("%d", &n);
    while(n--){
        int x;
        scanf("%d", &x);
        fun(x);
    }
    return 0;
}
```



#### 约数个数：

##### 公式：

(α1 + 1) * (α2 + 1) * …… * (αk + 1)  其中 一个数 N = p1 ^ α1 * p2 ^ α2 * …… * pk ^ αk;

##### 例题：

> ![image-20230321170914880](assets\image-20230321170914880.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<unordered_map> // 用哈希表来存， 因为map有序， 增删改比较慢， 本题不需要有序， 哈希表即可。
using namespace std;
typedef long long LL; // 以防爆int
const int mod = 1e9 + 7; 
int n;

int main(void){
    LL res = 1;
    scanf("%d", &n);
    unordered_map<int, int> primes; //第一个元素代表约数， 第二个元素代表次数
    while(n--){
        int x;
        scanf("%d", &x);
        for(int i = 2; i <= x / i; i++){ //试除法求约数
            while(x % i == 0){
                x /= i;
                primes[i]++;
            }
        }
        if(x > 1) primes[x]++; //最后记得特殊处理，是当约数比较大的时候的特殊情况！
    }
    
    for(auto prime : primes){ //范围遍历
        res = res * (prime.second + 1) % mod; //注意不要用 *= 因为还有取余操作
    }
    printf("%d", res);
    return 0;
}
```



#### 约数之和

##### 公式：

(p1 ^ 0 + p1 ^ 1 + …… + p1 ^ α1)  * (p2 ^ 0 + p2 ^ 1 + …… + p2 ^ α2)  * …… *(pk ^ 0 + pk ^ 1 + …… + pk ^ αk)  

##### 例题：

> ![image-20230321171648119](assets\image-20230321171648119.png)

##### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
#include<unordered_map> // 用哈希表来存， 因为map有序， 增删改比较慢， 本题不需要有序， 哈希表即可。
using namespace std;
typedef long long LL; // 以防爆int
const int mod = 1e9 + 7; 
int n;

int main(void){
    LL res = 1;
    scanf("%d", &n);
    unordered_map<int, int> primes; //第一个元素代表约数， 第二个元素代表次数
    while(n--){
        int x;
        scanf("%d", &x);
        for(int i = 2; i <= x / i; i++){ //试除法求约数
            while(x % i == 0){
                x /= i;
                primes[i]++;
            }
        }
        if(x > 1) primes[x]++; //最后记得特殊处理，是当约数比较大的时候的特殊情况！
    }
    
    for(auto prime : primes){ //范围遍历
        int p = prime.first, a = prime.second;
        LL t = 1; //不定义longlong 就会爆int！！！
        while(a--){
            t = (t * p + 1) % mod； //每次都要取模
        }
        res = res * t % mod;
    }
    printf("%d", res);
    return 0;
}
```

#### 欧几里得算法：

(求最大公约数) 也叫辗转相除法

##### 模板：

```C++
int gcd(int a, int b)
{
    return b ? gcd(b, a % b) : a;
}
```

##### 例题：

> ![image-20230321172727255](assets\image-20230321172727255.png)

##### AC代码：

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
int n;

int gcd(int a, int b){
    return b ? gcd(b, a % b) : a;
}

int main(void){
    scanf("%d", &n);
    while(n--){
        int a, b;
        scanf("%d%d", &a, &b);
        printf("%d\n", gcd(a, b));
    }
}
```

## 第四章：数学知识（二）

### 大纲：

1. 欧拉函数
2. 快速幂
3. 扩展欧几里得算法
4. 中国剩余定理

### 欧拉函数：

#### 定义：

phi( n ) : 1 ~ n中与 n 互质的数的个数

#### 公式：

若 N = p1 ^ α1 * p2 ^ α2 * …… * pk ^ αk ( 分解质因式 )

则 phi( N ) = N * (1 - 1 / p1) * (1 - 1 / p2) * …… * ( 1 - 1 / pn)   //利用容斥原理

#### 例题：

> ![image-20230322134541924](assets\image-20230322134541924.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
int main(void){
    scanf("%d", &n);
    while ( n-- ){
        int a;
        scanf("%d", &a);
        int res = a;
        for(int i = 2; i <= a / i; i++){
            if(a % i == 0){
                res = res / i * (i - 1);
                while(a % i == 0) a /= i;
            }
        }
        if(a > 1) res = res / a * (a - 1);
        printf("%d\n", res);
    }
    return 0;
}
```

### 筛法求欧拉函数：

主要解决求 1 ~ N 每个数的欧拉函数 如果用上述做法时间复杂度是O( N * sqrt（N）)

如果使用线性筛法可以降至 O（N）

#### 算法思路：

在线性筛法求素数的时候 可以同时把每个数的欧拉函数求出来

具体公式如下：

1. if( i 是质数 ) phi[i] = i - 1;
2. if( i % primes[j] == 0) phi[primes[j] * i] = primes[j] * phi[i];
3. if( i % primes[j] != 0) phi[primes[j] * i] = ( primes[j] - 1 )* phi[i];

#### 例题：

> ![image-20230322142600020](assets\image-20230322142600020.png)

#### AC代码：

```C++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N = 1000010;
typedef long long LL;
int n;
bool st[N];
int primes[N], cnt;
int phi[N];

LL get_eulers(int n){
    phi[1] = 1;
    for(int i = 2; i <= n; i++){
        if(!st[i]){
            primes[cnt++] = i;
            phi[i] = i -  1;
        }
        
        for(int j = 0; primes[j] <= n / i; j ++){
            st[primes[j] * i] = true;
            if(i % primes[j] == 0){
                phi[primes[j] * i] = primes[j] * phi[i];
                break;
            }
            phi[primes[j] * i] = (primes[j] - 1) * phi[i];
        }
    }
    LL res = 0;
    for(int i = 1; i <= n; i++){
        res += phi[i];
    }
    return res;
}

int main(void){
    scanf("%d", &n);
    cout << get_eulers(n) << endl;
    return 0;
}
```

### 快速幂：

用于快速的解决a^k mod p 的问题， 时间复杂度O（log k；

#### 算法思路：

1. 预处理出
   a^2^0 mod p
   a^2^1 mod p
   ………………
   a^2^log k mod p
2. a^k = a^2^x1 * a^2^x2 * a^2^x3 * ....
          = a^(2^x1 + 2^x2 + 2^x3 + ...)
3. 把k用二进制表示

#### 例题：

> ![image-20230328171617260](assets\image-20230328171617260.png)



#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
typedef long long LL;

int qmi(int a, int b, int p){
    int res = 1;
    while(b){
        if(b & 1) res = (LL) res * a % p;
        b >>= 1;
        a = (LL) a * a % p;
    }
    return res;
}

int main(void){
    scanf("%d", &n);
    while(n--){
        int a, b, p;
        scanf("%d%d%d", &a, &b, &p);
        printf("%d\n", qmi(a, b, p));
    }
    return 0;
}
```

### 扩展欧几里得算法：

#### 裴蜀定理

对于任意正整数a, b, 一定存在非零整数x， y ， 使得

a * x + b * y = (a, b)  //a和b的最大公约数

#### 算法思路：

> ![image-20230328175923764](assets\image-20230328175923764.png)

#### 例题：

> ![image-20230328175941229](assets\image-20230328175941229.png)

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n;

int exgcd(int a, int b, int &x, int &y){ //注意这里要用引用传递
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a%b, y, x);
    y -= a / b * x;
    return d;
}

int main(void){
    scanf("%d", &n);
    while(n--){
        int a, b, x, y;
        scanf("%d%d", &a, &b);
        exgcd(a, b, x, y);
        printf("%d %d\n", x, y);
    }
    return 0;
}
```

#### 例题：

> ![image-20230328181017566](assets\image-20230328181017566.png)

思路：

a * x  = b mod m; 等价于 a * x = m * y + b;

即 a * x - m * y = b;

令 y' = - y,  原式等于

a * x + m * y' = b;

如果b 是 (a, m) 的倍数，则一定有解(根据裴蜀定理)

结果让求 x 也就是让x 扩大 （b / d）倍，再对m取模即可。

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n;
typedef long long LL;

int exgcd(int a, int b, int &x, int &y){
    if(!b){
        x = 1, y = 0;
        return a;
    }
    int d = exgcd(b, a%b, y, x);
    y -= a / b * x;
    return d;
}

int main(void){
    scanf("%d", &n);
    while(n--){
        int a, b, m, x, y;
        scanf("%d%d%d", &a, &b, &m);
        int d = exgcd(a, m, x, y);
        if(b % d) printf("impossible\n");
        else printf("%d\n", (LL)x * (b / d) % m);
    }
    return 0;
}
```

### 中国剩余定理

#### 定理内容：

> ![image-20230328182758161](assets\image-20230328182758161.png)

有点难顶啊。。下次再整吧。。。。

## 第五章：动态规划（一）

### 大纲：

1. 常用模型 背包问题
2. 线性dp
3. 区间dp
4. 计数类dp
5. 数位统计dp
6. 状态压缩dp
7. 树形dp
8. 记忆化搜索

**理解Dp的方法**

- 状态表示（有几维变量）（每一个状态都是一个集合）
  - 表示的集合是什么
  - 表示的属性是什么（最大值，最小值，数量……)
- 状态计算（如何一步一步算出每一个状态）
  - 集合划分

**Dp问题的优化**

- 一般就是对Dp的代码或者Dp的方程做一个等价变形

### 背包问题

#### 0-1背包问题

特点：每件物品最多只能用一次

##### 例题：

> ![image-20230406142357067](assets\image-20230406142357067.png)

##### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i];
    }
    
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i-1][j];
            if(j >= v[i]) f[i][j] = max(f[i][j], f[i-1][j-v[i]] + w[i]);
        }
    
    cout << f[n][m] << endl;
}
```



#### 完全背包问题

特点：每件物品有无限个

##### 思路：

> ![image-20230406150133074](assets\image-20230406150133074.png)

##### 例题：

> ![image-20230406150202184](assets\image-20230406150202184.png)

##### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int n, m;
int v[N], w[N];
int f[N][N];

int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i];
    }
    for(int i = 1; i <= n; i++){
        for(int j = 0; j <= m; j++){
            f[i][j] = f[i-1][j];
            if(j >= v[i]){
                f[i][j] = max(f[i][j], f[i][j-v[i]] + w[i]);
            }
        }
    }
    cout << f[n][m] << endl;
    return 0;
}
```

​	



#### 多重背包问题

特点：每个物品最多有si个

##### 题目：

> ![image-20230406152450432](assets\image-20230406152450432.png)

##### 暴力做法：

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 110;
int n, m;
int v[N], w[N], s[N];
int f[N][N];
int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> v[i] >> w[i] >> s[i];
    }
    for(int i = 1; i <= n; i++)
        for(int j = 0; j <= m; j++)
            for(int k = 0; k <= s[i] && k * v[i] <= j; k++){
                f[i][j] = max(f[i][j], f[i-1][j-k*v[i]]+k*w[i]);
            }
    cout << f[n][m] << endl;
    return 0;
}
```



#### 多重背包问题优化版

**能把时间复杂度从O（nvs）下降到O（nvlogs）**

##### 思路：

把每个物品的个数s拆分成由1，2，4，8，16，……，2^k，m一共logs件商品

这样通过组合就可以选出从0~m个商品了

提前把每一件商品进行预处理，然后做一边零一背包就可以了

##### 优化代码：

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 25000;
int n, m;
int v[N], w[N];
int f[N];
int main(void){
    cin >> n >> m;
    int cnt = 0;
    for(int i = 1; i <= n; i++){
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1;
        while(k <= s){
            cnt ++;
            v[cnt] = k * a;
            w[cnt] = k * b;
            s -= k;
            k *= 2;
        }
        if(s > 0){
            cnt ++;
            v[cnt] = s * a;
            w[cnt] = s * b;
        }
    }
    n = cnt;
    for(int i = 1; i <= n; i++)
        for(int j = m; j >= v[i]; j--){
            f[j] = max(f[j],f[j-v[i]] + w[i]);
        }
    cout << f[m] << endl;
    return 0;
}
```

#### 分组背包问题

特点：物品有n组，每一组物品有若干个。

##### 例题：

> ![image-20230406161623217](assets\image-20230406161623217.png)

##### 算法思路：

把v和m用二维数组来存储每组每号的价值和体积

然后用01去选，只不过这次是三重循环。

##### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 110;
int n, m;
int s[N], v[N][N], w[N][N];
int f[N];
int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++){
        cin >> s[i];
        for(int j = 0; j < s[i]; j++){
            cin >> v[i][j] >> w[i][j];
        }
    }
    for(int i = 1; i <= n; i++){
        for(int j = m; j >= 0; j--){
            for(int k = 0; k < s[i]; k++){
                if(j >= v[i][k]) f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);
            }
        }
    }
    cout << f[m] << endl;
    return 0;
}
```

## 第五章：动态规划（二）

### 线性DP

#### 例题：

> ![image-20230407145801404](assets\image-20230407145801404.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 500;
int a[N][N], n, f[N][N];
const int INF = 1e9;
int main(void){
    cin >> n;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= i; j++)
            cin >> a[i][j];
    for(int i = 0; i <= n; i++)
        for(int j = 0; j <= i + 1; j++)
            f[i][j] = -INF;
    f[1][1] = a[1][1];
    for(int i = 2; i <= n; i++){
        for(int j = 1; j <= i; j++){
            f[i][j] = max(f[i-1][j-1] + a[i][j], f[i-1][j] + a[i][j]);
        }
    }
    int res = -INF;
    for(int i = 1; i <= n; i++){
        res = max(res, f[n][i]);
    }
    cout << res;
    return 0;
}
```

#### 例题：

> **![image-20230407162222657](assets\image-20230407162222657.png)**

#### AC代码：

```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
int a[N], f[N], n;
int main(void){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++){
        f[i] = 1;
        for(int j = 1; j < i; j++){
            if(a[j] < a[i]) f[i] = max(f[i], f[j] + 1);
        }
    }
    int res = 1;
    for(int i = 1; i <= n; i++) res = max(res, f[i]);
    cout << res;
    return 0;
}
```

#### 例题：

> ![image-20230407185552888](assets\image-20230407185552888.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 1010;
char a[N], b[N];
int n, m;
int f[N][N];
int main(void){
    cin >> n >> m;
    scanf("%s%s", a+1, b+1);
for(int i = 1; i <= n; i++)
for(int j = 1; j <= m; j++){
f[i][j] = max(f[i-1][j], f[i][j-1]);
if(a[i] == b[j]) f[i][j] = max(f[i][j], f[i-1][j-1]+1);
        }
    cout << f[n][m] << endl;
    return 0;
}
```

### 区间DP

#### 例题：

> ![image-20230407192634082](assets\image-20230407192634082.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 310;
int s[N], f[N][N];
int n;
int main(void){
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> s[i];
    for(int i = 1; i <= n; i++) s[i] += s[i-1];
    for(int len = 2; len <= n; len++){
        for(int i = 1; i + len - 1 <= n; i++){
            int l = i, r = i + len - 1;
            f[l][r] = 1e8;
            for(int k = l; k < r; k++){
                f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l-1]);
            }
        }
    }
    cout << f[1][n] << endl;
    return 0;
}
```

## 第五章：动态规划（三）

### 计数类DP

#### 例题：

**整数划分**

> ![image-20230413152652008](assets\image-20230413152652008.png)

#### AC代码

```C++
#include<iostream>//用完全背包写的
#include<algorithm>
using namespace std;
const int N = 1010, mod = 1e9 + 7;
int n;
int f[N];
int main(void){
    cin >> n;
    f[0] = 1;
    for(int i = 1; i <= n; i++)
        for(int j = i; j <= n; j++)
            f[j] = (f[j] + f[j - i]) % mod;
    cout << f[n];
    return 0;
}
```



### 数位统计DP

#### 例题：

**计数问题**

> ![image-20230412192609826](assets\image-20230412192609826.png)
>
> ![image-20230412192645190](assets\image-20230412192645190.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
#include<vector>

using namespace std;

const int N = 10;

int get(vector<int> num, int l, int r){
    int res = 0;
    for(int i = l; i >= r; i--) res = res * 10 + num[i];
    return res;
}

int power10(int x){
    int res = 1;
    while(x -- ) res *= 10;
    return res;
}

int count(int n, int x){
    if(!n) return 0;
    vector<int> num;
    while(n){
        num.push_back(n % 10);
        n /= 10;
    }
    n = num.size();
    int res = 0;
    for(int i = n - 1 - !x; i >= 0; i--){
        if(i < n - 1){
            res += get(num, n-1, i+1) * power10(i);
            if(!x) res -= power10(i);
        }
        if(num[i] == x) res += get(num, i-1, 0) + 1;
        else if(num[i] > x) res += power10(i);
    }
    return res;
}

int main(void){
    int a, b;
    while(cin >> a >> b, a){
        if(a > b) swap(a, b);
        for(int i = 0; i <= 9; i++){
            cout << count(b, i) - count(a - 1, i) << " ";
        }
        cout << endl;
    }
    return 0;
}
```



### 状态压缩DP

#### 例题：

**蒙德里安的梦想**

> ![image-20230412205331692](assets\image-20230412205331692.png)
> ![image-20230412205343749](assets\image-20230412205343749.png)

#### AC代码

```c++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 12, M = 1 << N;
int n, m;
long long f[N][M];
bool st[M];
int main(void){
    while(cin >> n >> m, n || m){
        for(int i = 0; i < 1 << n; i++){
            int cnt = 0;
            st[i] = true;
            for(int j = 0; j < n; j++){
                if(i >> j & 1){
                    if(cnt & 1) st[i] = false;
                    cnt = 0;
                }
                else cnt ++;
            }
            if(cnt & 1) st[i] = false;
        }
        memset(f, 0, sizeof f);
        f[0][0] = 1;
        for(int i = 1; i <= m; i++)
            for(int j = 0; j < 1 << n; j++)
                for(int k = 0; k < 1 << n; k++)
                    if((j & k) == 0 && st[j | k])
                        f[i][j] += f[i-1][k];
        cout << f[m][0] << endl;
    }
    return 0;
}
```

#### 例题

**最短Hamilton路径**

> ![image-20230412212148055](assets\image-20230412212148055.png)

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 20, M = 1 << N;

int n;
int w[N][N];
int f[M][N];
int main(void)
{
    cin >> n;
    for(int i = 0; i < n; i++)
        for(int j = 0; j < n; j++)
            cin >> w[i][j];
    memset(f, 0x3f, sizeof f);
    f[1][0] = 0;
    for(int i = 0; i < 1 << n; i++)
        for(int j = 0; j < n; j++)
            if(i >> j & 1)
                for(int k = 0; k < n; k++)
                    if(i >> k & 1)
                        f[i][j] = min(f[i][j], f[i - (1 << j)][k] + w[k][j]);
    cout << f[(1 << n) - 1][n - 1];
    return 0;
}
```

### 树形DP

#### 例题：

**没有上司的舞会**

> ![image-20230412215116986](assets\image-20230412215116986.png)	![image-20230412215124771](assets\image-20230412215124771.png)

#### AC代码

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 6060;
int n;
int h[N], e[N], ne[N], idx;
int happy[N];
int f[N][2];
bool has_father[N];
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

void dfs(int u)
{
    f[u][1] = happy[u];
    for(int i = h[u]; i != -1; i = ne[i]){
        int j = e[i];
        dfs(j);
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0], f[j][1]);
    }
}

int main(void){
    cin >> n;
    for(int i = 1; i <= n; i++) scanf("%d", &happy[i]);
    memset(h, -1, sizeof h);
    for(int i = 0; i < n - 1; i++){
        int a, b;
        scanf("%d%d", &a, &b);
        add (b, a);
        has_father[a] = true;
    }
    int root = 1;
    while(has_father[root]) root++;
    dfs(root);
    cout << max(f[root][0], f[root][1]);
    return 0;
}
```

### 记忆化搜索

#### 优点：

好写， 代码复杂度低

#### 例题：

**滑雪**

> ![image-20230412221709174](assets\image-20230412221709174.png)
>
> ![image-20230412221716073](assets\image-20230412221716073.png)

#### AC代码：

```C++
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 330;
int n, m;
int g[N][N];
int f[N][N];

int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};

int dp(int x, int y){
    int &v = f[x][y];
    if(v != -1) return v;
    v = 1;
    for(int i = 0; i < 4; i++){
        int a = x + dx[i], b = y + dy[i];
        if(a >= 1 && a <= n && b >= 1 && b <= m && g[a][b] < g[x][y])
            v = max(v, dp(a, b)+1);
    }
    return v;
}

int main(void){
    cin >> n >> m;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            cin >> g[i][j];
    memset(f, -1, sizeof f);
    int res = 0;
    for(int i = 1; i <= n; i++)
        for(int j = 1; j <= m; j++)
            res = max(res, dp(i, j));
    cout << res;
    return 0;
}
```

## 第六章：贪心（一）

### 区间问题

#### 例题：

**区间选点**

> ![image-20230414153836530](assets\image-20230414153836530.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 100010;
int n;
struct Range{
    int l, r;
    bool operator < (const Range & W) const{
        return r < W.r;
    }
}range[N];

int main(void){
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    sort(range, range + n);
    int res = 0, ed = -2e9;
    for(int i = 0; i < n; i++){
        if(range[i].l > ed){
            res ++;
            ed = range[i].r;
        }
    }
    cout << res;
    return 0;
}
```

#### 例题：

**最大不相交区间数量**

> ![image-20230414154435464](assets\image-20230414154435464.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 100010;
int n;
struct Range{
    int l, r;
    bool operator < (const Range & W) const{
        return r < W.r;
    }
}range[N];

int main(void){
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    sort(range, range + n);
    int res = 0, ed = -2e9;
    for(int i = 0; i < n; i++){
        if(range[i].l > ed){
            res ++;
            ed = range[i].r;
        }
    }
    cout << res;
    return 0;
}
```

#### 例题：

**区间分组**

> ![image-20230414163226565](assets\image-20230414163226565.png)

#### AC代码：

```C++
#include<iostream>
#include<algorithm>
#include<queue>

using namespace std;

const int N = 100010;

int n;
struct Range{
    int l, r;
    bool operator < (const Range &W) const
    {
        return l < W.l;
    }
}range[N];

int main(void){
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d%d", &range[i].l, &range[i].r);
    sort(range, range + n);
    priority_queue<int, vector<int>, greater<int> > heap;
    for(int i = 0; i < n; i++){
        auto r = range[i];
        if(heap.empty() || heap.top() >= r.l) heap.push(r.r);
        else{
            heap.pop();
            heap.push(r.r);
        }
    }
    cout << heap.size();
    return 0;
}
```

#### 例题：

**区间覆盖**

> ![image-20230414164832503](assets\image-20230414164832503.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    int st, ed;
    scanf("%d%d", &st, &ed);
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    int res = 0;
    bool success = false;
    for (int i = 0; i < n; i ++ )
    {
        int j = i, r = -2e9;
        while (j < n && range[j].l <= st)
        {
            r = max(r, range[j].r);
            j ++ ;
        }

        if (r < st)
        {
            res = -1;
            break;
        }

        res ++ ;
        if (r >= ed)
        {
            success = true;
            break;
        }

        st = r;
        i = j - 1;
    }

    if (!success) res = -1;
    printf("%d\n", res);

    return 0;
}
```

### Huffman树

#### 例题：

**合并果子**

> ![image-20230414165540472](assets\image-20230414165540472.png)
>
> ![image-20230414165547449](assets\image-20230414165547449.png)

#### AC代码：

```C++
#include <iostream>
#include <algorithm>
#include <queue>

using namespace std;

int main()
{
    int n;
    scanf("%d", &n);

    priority_queue<int, vector<int>, greater<int>> heap;
    while (n -- )
    {
        int x;
        scanf("%d", &x);
        heap.push(x);
    }

    int res = 0;
    while (heap.size() > 1)
    {
        int a = heap.top(); heap.pop();
        int b = heap.top(); heap.pop();
        res += a + b;
        heap.push(a + b);
    }

    printf("%d\n", res);
    return 0;
}
```

## 第六章：贪心（二）

### 排序不等式

#### 例题：

**排序打水**

> ![image-20230418185007907](assets\image-20230418185007907.png)

#### AC代码

```c++
#include<iostream>
#include<algorithm>
using namespace std;
typedef long long LL;
const int N = 100010;
int n;
int t[N];
int main(void){
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d", &t[i]);
    sort(t, t + n);
    LL res = 0;
    for(int i = 0; i < n; i++) res += t[i] * (n - i - 1);
    printf("%lld\n",res);
    return 0;
}
```

### 绝对值不等式

#### 例题：

**货仓选址**

> ![image-20230418185155407](assets\image-20230418185155407.png)

#### AC代码

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 100010;
int n;
int a[N];
int main(void)
{
    cin >> n;
    for(int i = 0; i < n; i++) scanf("%d", &a[i]);
    sort(a, a+n);
    int res = 0;
    for(int i = 0; i < n; i++) res += abs(a[i] - a[n/2]);
    cout << res << endl;
    return 0;
}
```

### 推公式

#### 例题：

**耍杂技的牛**

> ![image-20230418185512032](assets\image-20230418185512032.png)
>
> ![image-20230418185518476](assets\image-20230418185518476.png)

#### AC代码：

```C++
#include<iostream>
#include<algorithm>
using namespace std;
const int N = 50010;
typedef pair<int, int> PII;
int n;
PII cow[N];
int main(void){
    cin >> n;
    for(int i = 0; i < n; i++){
        int w, s;
        scanf("%d%d", &w, &s);
        cow[i] = {w + s, w};
    }
    sort(cow, cow + n);
    int res = -2e9, sum = 0;
    for(int i = 0; i < n; i++){
        int w = cow[i].second, s = cow[i].first - w;
        res = max(res, sum - s);
        sum += w;
    }
    cout << res <<endl;
    return 0;
}
```

## 第七章：时间复杂度分析

由数据范围反推算法复杂度以及算法内容

![微信截图_20210814171057.png](assets\102790_aaf31c80fc-微信截图_20210814171057.png)

**完结。**

